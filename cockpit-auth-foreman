#! /usr/bin/python

# This program acts as a external authentication helper for Cockpit.
# It is spawned as part of establishing a new Cockpit session on a
# remote machine.

import sys
import os
import json
import urllib2
import base64
import subprocess
import urlparse
import socket
import select

def dbg(str):
    sys.stderr.write(str + "\n")

def usage():
    sys.stderr.write("usage {} host-id\n".format(sys.argv[0]))
    sys.exit(os.EX_USAGE)

# Cockpit protocol, encoding and decoding of control messages.

def send_control(msg):
    text = json.dumps(msg)
    dbg("-> %s" % text)
    os.write(1, "{}\n\n{}".format(len(text)+1, text))

def read_size(fd):
    sep = '\n'
    size = 0
    seen = 0

    while True:
        t = os.read(fd, 1)

        if not t:
            return 0

        if t == '\n':
            break

        size = (size * 10) + int(t)
        seen = seen + 1

        if seen > 7:
            raise ValueError("Invalid frame: size too long")

    return size

def read_control():
    size = read_size(1)

    data = ""
    while size > 0:
        d = os.read(1, size)
        size = size - len(d)
        data = data + d

    dbg("<- %s" % data.strip())
    return json.loads(data)

# Specific control messages

def send_auth_challenge(challenge):
    send_control({
        "command": "authorize",
        "cookie": "1234", # must be present
        "challenge": challenge
    })

def send_auth_response(response):
    send_control({
        "command": "authorize",
        "response": response
    })

def read_auth_reply():
    cmd = read_control()
    response = cmd.get("response")
    if cmd.get("command") != "authorize" or not response:
        raise ValueError("Did not receive a valid authorize command")
    return response

def exit_with_problem(problem, message, auth_methods):
    send_control({
        "command": "init",
        "problem": problem,
        "message": message,
        "auth-method-results": auth_methods
    })
    sys.exit(1)

# Talking to the Foreman API

def get_token_from_auth_data(auth_data):
    f = auth_data.split(" ")
    return f[1]

def api_call(path, token):
    dbg("=> %s" % path)
    req = urllib2.Request("http://localhost:3000/api/" + path, None,
                          { "Cookie": "_session_id=%s" % token })
    try:
        resp = urllib2.urlopen(req).read()
    except urllib2.URLError, err:
        if hasattr(err, "code"):
            if err.code == 401:
                exit_with_problem("authentication-failed",
                                  "Token was not valid",
                                  { "password": "not-tried", "token": "denied" })
            elif err.code == 404:
                exit_with_problem("access-denied",
                                  "Host with id %s is not known" % args[1],
                                  None)
        raise
    dbg("<= %s" % resp)
    return json.loads(resp)

# Interactive SSH via the smart proxy

def ssh_proxy(urlstr):
    url = urlparse.urlparse(urlstr)
    sock = socket.create_connection((url.hostname, url.port))

    client_eof = False
    sock_eof = False

    inp_buf = "POST /bash HTTP/1.1\nConnection: upgrade\nUpgrade: raw\n\n"
    out_buf = ""

    expecting_http_header = True

    while True:
        readers = [ ]
        writers = [ ]
        if not client_eof:
            readers.append(0)
        if not sock_eof:
            readers.append(sock)
        if len(inp_buf) > 0:
            writers.append(sock)
        if len(out_buf) > 0:
            if expecting_http_header:
                header_end = out_buf.find("\r\n\r\n")
                if header_end >= 0:
                    header = out_buf[1:header_end]
                    out_buf = out_buf[header_end+4:]
                    expecting_http_header = False
            else:
                writers.append(1)
        if len(readers) + len(writers) == 0:
            dbg("done")
            break
        (r, w, x) = select.select(readers, writers, [ ])
        if sock in r:
            data = os.read(sock.fileno(), 4096)
            # dbg("<-s %s" % data)
            out_buf += data
            if data == "":
                # dbg("s eof")
                sock_eof = True
                if out_buf == "":
                    # dbg("c close")
                    os.close(1)
        if sock in w:
            n = os.write(sock.fileno(), inp_buf)
            # dbg("->s %s" % n)
            inp_buf = inp_buf[n:]
            if inp_buf == "" and client_eof:
                # dbg("s close")
                sock.shutdown(socket.SHUT_WR);
        if 0 in r:
            data = os.read(0, 4096)
            # dbg("<-c %s" % data)
            inp_buf += data
            if data == "":
                # dbg("c eof")
                client_eof = True
                if inp_buf == "":
                    # dbg("s close")
                    sock.shutdown(socket.SHUT_WR);
        if 1 in w:
            n = os.write(1, out_buf) # XXX - catch EPIPE here
            # dbg("->c %s" % n)
            out_buf = out_buf[n:]
            if out_buf == "" and sock_eof:
                # dbg("c close")
                os.close(1)

# Main

def main(args):
    if len(args) != 2:
        usage()

    send_auth_challenge("*")
    token = get_token_from_auth_data(read_auth_reply())
    data = api_call("remote_execution/ssh_params?host_id=%s" % args[1], token)

    ssh_proxy(data["proxy"])

if __name__ == '__main__':
    main(sys.argv)
